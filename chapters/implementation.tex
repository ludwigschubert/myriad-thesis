\chapter{Implementation}
\label{chapter:Implementation}

This chapter is concerned with technical details of how Myriad was implemented. The collaborative development process is described, as are actual system components and their functionality.

\section{Preparation and Tools}



\subsection{Development Environment}



\subsection{Collaborative Development}



\subsubsection{\code{git}, \code{gitflow} and Github}



\subsection{Deployment}
\label{subsection:Deployment}



\subsubsection{Deployment Tool \code{Capistrano}}




\section{Server Component}


\subsection{Workers and their Jobs}

Myriad does a lot of work ``behind-the-scenes'', when users are not actively using the system through their browsers. An array of background workers and tasks was created to tackle this challenge:


As we spent a lot of time figuring out the intricacies of the Gmail IMAP implementation and the manifold cases that can occur when normal (or heavy) users go about their daily email business without considering the restrictions of poor Myriad, we want to spare you repeating the same. We hope to have brought the fetching and email creation logic to a relatively stable state, yet we are certain there remain a bunch of holes that could cause failures in edge cases.
If you do not need to touch the code, you might find the following explanation too detailed, so you shouldn't waste your time with it (bar this overview section). For anybody working with the fetching code, however, the following information should prove very useful - especially if you are unfamiliar with email headers, IMAP protocol details and the like.
In brief, our fetching process works as follows:
1.	Identifying emails on the Gmail server: First, we connect to the user's Gmail account and identify the UIDs (one of many types of email identifiers, see below for a more detailed explanation) of all emails we want to fetch. We use multiple different queries for that, which will later be explained in more detail. Before we move on to the next step, we filter out emails in our database whose UIDs we already know, i.e. have fetched before.
2.	Fetching and processing email data: For the remaining UIDs, we fetch the corresponding email from Gmail, create a Mail object (from the mail gem) for it and determine its type – IncomingFetchedEmail, OutgoingFetchedEmail, etc.
3.	Email creation in Myriad: As a last (but not trivial) step we try to use the information from the Mail object to create an Email object in Myriad.


\subsection{Maintenance and Rake Tasks}

\section{rake db:validate}

We had to perform a big number\footnote{\lstinline{cd ~/myriad/db/migrations && ls -l | awk '!/^d/\{print \}' | wc -l} returns 82 migrations.} of database migrations while already handling live tester's data. This data included our professor's emails, so I searched for a way to ensure our migrations and code changes would not create database records that would be considered invalid by the changed validation code, a problem that's not usually detected during a migration and will lead to hard-to-debug problems during usage. The solution we built is a rake task called ``db:validate''. It dynamically discovers all \gls{activerecord} classes and runs their validations on them. As part of the test suite it would be run against a copy of the production database before deploying a new release. While the actual class got more complicated to account for exceptional validation behavior, progress indication, and interactive deletion capabilities, the original formulation is still intriguingly simple.

\begin{lstlisting}
  def invalid_records
    classes = ActiveRecord::Base.descendants
    classes.flat_map{ |class| class.all.reject(&:valid?) }
  end
\end{lstlisting}

\section{rake backup:db \& rake backup:attachments}

Since we were working on live data we automatically created a backup of the database and external message attachments before every deploy using these two rake tasks.

\section{rake fetch:...}

The |fetch| tasks included debug tools for every switch we made in how we fetched emails from Google. Since after such a change we had to ``migrate'' our database to the new expectations about which messages were fetched, we used these tasks to do so. All of them were written to be idempotent so we could also run them again and look at log outputs for debugging reasons.

\section{rake idle}

The IMAP IDLE background task was also created as a rake task, since it would need access to the database's user information. It contains a while true loop that checks and restarts child processes for opening an IMAP connection for every user, and restarting them when they got closed.

\section{rake resque:...}

Contains a collection of scripts that setup, start, and restart the resque service for background workers.

\pagebreak
\section{Architecture}
\label{sec:Architecture}

Myriad is built around the interaction of five model level concepts, implemented as model classes, and a set of assisting subsystems:
|Campaign|s, which have a set of |Email|s and a bunch of |Contact|s as recipients. The relation between the campaign and the contacts is called a |Conversation|; the relation between campaign and the emails is called a |Template|, with the emails being ``instances'' of |Template|s.

The shown class diagrams follow a subset of the UML 2.0 class diagram standard\cite{uml}. Since these diagrams are primarily focussed on Myriad's data model, they are first and foremost Entity Relationship diagrams. They are simplified for illustrative purposes and do not constitute an exact specification.

\insertfigure{figures/cd_main.pdf}{Myriad is built around the interaction of 5 model level classes.}{CD-Main}{1}


\subsection{Contact}

Contacts are the names and email addresses of the people you want to email.
They are created when importing from spreadsheets, when typing an email address into a To: field, or when importing existing emails by adding a Gmail label to them. Contacts belong to users. This means that there is only one fred@gmail.com for each user and this fred@gmail.com may be linked to multiple campaigns of that user. This is also used to provide a \gls{crm}-like functionality where inside a conversation all other conversations with this contact in other campaigns are linked.

\subsection{Template}

Templates are prototypes of emails. They consist of body text that can contain placeholders, a subject, actions that are triggered when they are sent, and rules that can send them automatically. |Action|s and |Rule|s are described later on.

\subsection{Email}

Emails are instantiations of Templates. Their body doesn’t contain placeholders anymore, but only the merged email body. They have a delivery status, for example, and keep lots of information on their external representations, like a \code{message\_id}, UIDs for IMAP folders, thread IDs (THRIDs) for Gmail, etc.

\subsubsection{FetchedEmail}

|FetchedEmail| represents Emails that were fetched as raw data from an IMAP server. |FetchedEmail|s encapsulate their respective |RawMail|s.

\subsubsection{IncomingFetchedEmail}

|IncomingFetchedEmail| represents an email from someone else than the user that was fetched from an IMAP server. E.g.: responses from recipients.

\subsubsection{OutgoingFetchedEmail}

|OutgoingFetchedEmail| represents an email the user wrote themselves, but that was fetched from an IMAP server. E.g.: Emails the user wrote in their personal email client, but still in response to recipients of a current campaign.

\subsubsection{CreatedEmail}

|CreatedEmail| represents Emails that were created by Myriad. They don't have a |Rawmail|, but |CreatedEmail| provides functionality for serializing to a raw text representation for sending.

\subsubsection{OutgoingCreatedEmail}

|OutgoingCreatedEmail| represents an email the user wrote as a message template and was later generated and usually sent by Myriad.

\subsubsection{IncomingCreatedEmail}

While, at first sight, it might seem like an \emph{incoming} email could never be \emph{created} by the system, this could be used for a multitude of plausible scenarios, such as sending persistent messages to the user (instead of the more ephemeral on-screen notifications), importing emails from a non \code{IMAP} compatible email server, or even integrating chat systems, making incoming chat messages appear as emails to the system.

\subsection{Campaign}

Campaigns are a collection of templates and meta information like a connected Google Drive spreadsheet. They additionally contain a list of Keys, which are described later. One can think of keys as the column headers of the synced spreadsheet.

\subsection{Conversation}

Conversations are like email threads in gmail, but scoped to a specific campaign and contact. They contain all the emails a contact wrote or received within a campaign.

\subsection{Key \& Value}

\insertfigure{figures/cd_key_value.pdf}{Key and Value together allow for storing arbitrary information about a contact in a campaign.}{CD-Key-Values}{1}

One goal of a campaign can be the collection of information. To achieve this, users create a data schema made up of Keys, that they -- or one of the assistants they share the campaign with -- fills with Contact-specific Values. The Keys are a name – the header of the spreadsheet column. Values have a content – the content of a spreadsheet cell in the row of the contact they belong to.
\pagebreak
\subsection{Rules \& KeyBinding}

\insertfigure{figures/cd_rules.pdf}{Rules rely on different ``bindings'' to define their matching criteria.}{CD-Rules}{1}

Searches allow users to constrain the set of all conversations to a subset of them by defining criteria those conversations match. Each search consists of zero or more KeyBindings, zero or more TemplateBindings, as well as an optional conversation status constraint. A KeyBinding is a value that a key must have to satisfy a specific search. Similarly, a TemplateBinding tb of search s specifies a Template t such that a conversation c matches s if c contains an email e, and e is an instantiation of t.
For example, a search might specify that a conversation should be unread to be part of the search’s results. But we also want to allow users to specify constraints on their own Keys, e.g. coming? = ``yes''. For that, we needed a flexible way to specify those constraints. So we came up with the concept of a KeyBinding; it ``binds the free Key variable to a specific value''. So a KeyBinding associates a search with a Key that contains a specific value.
Searches are saved to the database. If they specify a template to be sent, we consider them to be ``Rules'' that can be automatically triggered. This persisting of searches is also used to remember recent searches.

\pagebreak
\subsection{ValueSettingActions}

When a |ValueSettingAction| is attached to a |Template|, and the Template is used to generate an |Email|, the |ValueSettingAction| is triggered. These actions can be used to change an arbitrary key's value to a specified value, after which rules are evaluated again.

\insertfigure{figures/cd_actions.pdf}{ValueSettingActions allow a template to set a certain Key's value to a predefined value. Together with Rules, this allows for custom, state-machine-like behavior specification.}{CD-Actions}{1}

\subsection{Notification}

Notifications are used to ``notify'' users, but they can also hold state that can be used internally by the system. For example, when a user's credentials were rejected by Google, an InvalidCredentials Notification is attached to this user. The system checks for these when syncing Emails and knows to avoid users with invalid credentials. At the same time the notification is persistently shown to the user so they are made aware of the problem. Notifications are like state descriptors that can be attached to other objects.

Notifications themselves are an abstract class which contains a polymorphic Type field, and an ID. We use this information to attach Notifications to any ActiveRecord object in our database. There is a whole class hierarchy beneath Notification, containing classes like |ErrorNotification|, which uses the aforementioned feature to attach errors or warnings to resources. There are also very specific subclasses like |TemplateSentToSearchResultsActivityNotification|, which are used to notify users. Another example would be a |SpreadsheetSyncingNotification|, which is also used to inform users. Groups of Notification Subclasses are defined, which are then displayed in different parts of the UI, for example on the Admin Dashboard or on top of the screen for the respective user. They act as a persistent ``notice'' as a message to users is usually called in \gls{ror}.

\subsubsection{UnexpectedStateNotification}

We used UnexpectedStateNotification as an alternative to an assert statement in production code. This allowed us to recover from non-critical errors, while still being made aware of where our code behaved unexpectedly. A good example where these really helped was spreadsheet syncing: we originally expected to have write access to a spreadsheet if a user's credentials were valid. Unfortunately Google Docs allows users to lose write access they had while creating the Myriad campaign. An |UnexpectedStateNotification| in the branch that handled authentication failure for spreadsheet syncing helped us discover this error.

\subsubsection{ExceptionNotification}

A simple way to save a runtime exception for review from the Admin Dashboard. |ExceptionNotification|s even include a stack trace to make debugging simpler without having to read through megabytes of logfiles.

\subsubsection{ErrorNotification}

ErrorNotifications can be assigned to resources, but also have a resolve method. For example, we used |ErrorNotification|s to implement an |InvalidCredentialsErrorNotification| that is attached to a user if Google rejects their credentials. When, at a later point, the credentials work again, one can call |#resolve| on the |InvalidCredentialsErrorNotification|.
Unfortunately we switched to also use them to notify not about an error, but simply about a state, for example a SpreadsheetSyncingNotification. Thus a future refactoring might rename them to PersistentNotification.

\section{``Interesting Practices''}

During the development process we discovered a set of ``Interesting Practices''\footnote{A wordplay on ``Best Practices'', an overused term to describe methods or practices that have repeatedly produced good or above-average results.} that didn't seem to fit into any specific software development methodology.

\subsection{Lean Workers with AbstractWorker}

When faced with the task to build a DRY function to start worker threads for all workers, there was no simple way. Additionally, each worker needed a queue name as configuration. Having learned from ActiveModel, I built |AbstractWorker|. It takes care of generating queue names from the class names of it’s subclasses. The descendants method, which returns all subclasses, can be iterated over. This allows starting a worker thread for every queue. It also allowed extracting the ResqueDirector plugin into AbstractWorker, which starts those workers automatically in our Development environment. So one can simply subclass AbstractWorker and rest assured that worker threads will be started for the new subclass automatically, both in development and in production.

\subsection{A small, fixed set of core Ruby extensions}

A dynamic language like ruby makes it trivially easy to reopen core classes.\footnote{By simply redefining a class one can extend it.} While initially this seems like a convenience, it's easy to lose track of already implemented extensions. One risks colliding method names\footnote{Ruby 2.0 finally fixed this by introducing \emph{refinements}, a way to extend classes namespaced to the current module.} and reusability is higher if the extension is packaged as a module which is then included where needed.

However, we did decide to keep a set of our extensions, which we felt were both useful and idiomatic. Here's a list of them, together with explanations why we kept them even through multiple code cleanups:

\subsubsection{String}

\begin{description}

\item[remove\_all\_whitespace] A common task when interfacing with APIs, especially when interfacing with IMAP where one can't use a proper parser. This came up multiple times during development, and a commonly suggested solution is to use regular expressions, like so: |gsub /\s+/, ''|. While working perfectly fine, we wanted a more expressive name. This was left as an extension because similar whitespace altering functions like |#strip| or  |#squish| are also declared directly on |String|.
\\
\begin{lstlisting}
  "  This is a string  !   ".remove_all_whitespace
   => "Thisisastring!"
\end{lstlisting}

\item[similar\_to?] A custom equivalence class on |String|s, which are similar if one only considers numbers and downcased letters. This is used to match placeholders with spreadsheet column headers, for example.
In our experience users often used ``First Name'' instead of ``first\_name'' and we wanted to offer an equivalence class that was sufficiently big, while avoiding being totally fuzzy.
\\
\begin{lstlisting}
  "first_name".similar_to? "First Name"
   => true
\end{lstlisting}

\item[ellipsisize] Takes a string and information on how how much of it to keep. It adds an ellipsis where the string was cut off. We used it in many places throughout the interface, for example for only displaying the first line of a collapsed email.
\\
\begin{lstlisting}
  "Supercalifragilisticexpialidocious".ellipsisize
  => "Sup...ous"
\end{lstlisting}


\item[to\_bool] Once again an indication of working with badly specified protocols. This was needed after some Javascript libraries apparently disagree about how to encode |true| in a \gls{url} parameter.
\\
\begin{lstlisting}
  ['true', 't', 'yes', 'y', '1'].map(&:to_bool).all?
  => true
  ['false', 'f', 'no', 'n', '0'].map(&:to_bool).none?
  => true
\end{lstlisting}

\end{description}

\subsubsection{Hash}

\begin{description}

\item[deep\_find] This does a deep traversal of a Hash, looking for any key that matches the argument of this method. When working with APIs that return structured data the format is usually fixed, but we experienced slight inconsistencies for Google's different versions of its OAuth APIs. Of course this method will run into trouble if a key occurs multiple times, but when used in the right places, it makes parsing structured responses incredibly solid.
\\
\begin{lstlisting}
  nested_hash
  => {
      "a key"=>"a value",
      "a nested hash" =>
      {
        "another key"=>"another value",
        "the key"=>"the value"
      }
     }

  simple_hash
  => {
      "another key"=>"another value",
      "the key"=>"the value"}
     }

  simple_hash.deep_find "the key"
  => "the value"

  nested_hash.deep_find "the key"
  => "the value"
\end{lstlisting}

\end{description}

\subsubsection{Array}

\begin{description}

\item[uniq?] Checks whether all elements inside the receiving array are unique. This was not used to abuse |Array|s as |Set|s, but rather to check user input.

\item[contains\_duplicates?] Semantic alias of |not uniq?|, this was the method that was actually used in code.
\\
\begin{lstlisting}
  ['word', 'thing', 'word'].contains_duplicates?
  => true
\end{lstlisting}

\end{description}

