\chapter{Implementation}
\label{chapter:Implementation}

This chapter is concerned with technical details of how Myriad was implemented. The collaborative development process is described, as are actual system components and their functionality.

The shown class diagrams follow a subset of the UML 2.0 class diagram standard\cite{uml}. Since these diagrams are primarily focussed on Myriad's data model, they are first and foremost Entity Relationship diagrams. They are simplified for illustrative purposes and do not constitute an exact specification.

\section{Preparation and Tools}



\subsection{Development Environment}



\subsection{Collaborative Development}



\subsubsection{\code{git}, \code{gitflow} and Github}



\subsection{Deployment}
\label{subsection:Deployment}



\subsubsection{Deployment Tool \code{Capistrano}}




\section{Server Component}


\subsection{Workers and their Jobs}


\subsection{Maintenance and Rake Tasks}


\pagebreak
\section{Architecture}

Myriad is built around the interaction of 5 model level concepts, or classes, and a set of assisting subsystems.
|Campaigns|, which have a set of |Email|s and a bunch of |Contact|s as recipients. The relation between the campaign and the contacts is called |Conversation|; the relation between campaign and the emails is called |Template|.

\insertfigure{figures/cd_main.pdf}{Myriad is built around the interaction of 5 model level classes.}{CD-Main}{1}


\subsection{Contact}

Contacts are the names and email addresses of the people you want to email.
They are created when importing from spreadsheets, when typing an email address into a To: field, or when importing existing emails by adding a Gmail label to them. Contacts belong to users. This means that there is only one fred@gmail.com for each user and this fred@gmail.com may be linked to multiple campaigns of that user.

\subsection{Template}

Templates are prototypes of emails. They consist of body text that can contain placeholders, a subject, actions that are triggered when they are sent, and rules that can send them automatically.

\subsection{Email}

Emails are instantiations of Templates. Their body doesn’t contain placeholders anymore, but only the merged email body. They have a delivery status, for example, and keep lots of information on their external representations, like a \code{message\_id}, UIDs for IMAP folders, thread IDs (THRIDs) for Gmail, etc.

\subsubsection{FetchedEmail}

|FetchedEmail| represents Emails that were fetched as raw text from an IMAP server. |FetchedEmail|s encapsulate their respective |RawMail|s.

\subsubsection{IncomingFetchedEmail}

|IncomingFetchedEmail| represents an email from someone else than the user that was fetched from an IMAP server. E.g.: responses from recipients.

\subsubsection{OutgoingFetchedEmail}

|OutgoingFetchedEmail| represents an email the user wrote themselves, but that was fetched from an IMAP server. E.g.: Emails the user wrote in their personal email client, but still in response to recipients of a current campaign.

\subsubsection{CreatedEmail}

|CreatedEmail| represents Emails that were created by Myriad. They don't have a Rawmail, but |CreatedEmail| provides functionality for serializing to a raw text representation.

\subsubsection{OutgoingCreatedEmail}

|OutgoingCreatedEmail| represents an email the user wrote as a message template  and was later generated by Myriad.

\subsubsection{IncomingCreatedEmail}

This class is not implemented yet. While, at first sight, it might seem like an \emph{incoming} email could never be \emph{created} by the system, this could be used for a multitude of plausible scenarios, such as sending persistent messages to the user (instead of the more ephemeral on-screen notifications), importing emails from a non \code{IMAP} compatible email server, or even integrating a chat system, making incoming chat messages appear as emails to the system.

\subsection{Campaign}

Campaigns are a collection of templates and meta information like a connected Google Drive spreadsheet. They additionally contain a list of Keys. You can think of keys as column headers in a spreadsheet.

\subsection{Conversation}

Conversations are like email threads in gmail, but scoped to a specific campaign and contact. They contain all the emails a contact wrote or received within a campaign.

\subsection{Key \& Value}

\insertfigure{figures/cd_key_value.pdf}{Key and Value together allow for storing arbitrary information about a contact in a campaign.}{CD-Key-Values}{1}

One goal of a campaign can be the collection of information. For that, users create a data schema made up of Keys, that they (or somebody they share the campaign with) fill with Values. The Keys consist of a name – the header of the spreadsheet column – while values have a content – the content of a spreadsheet cell in the row of the contact they belong to.
\pagebreak
\subsection{Rules \& KeyBinding}

\insertfigure{figures/cd_rules.pdf}{Rules rely on different ``bindings'' to define their matching criteria.}{CD-Rules}{1}

Searches allow users to constrain the set of all conversations to a subset of them by defining criteria those conversations match. Each search consists of zero or more KeyBindings, zero or more TemplateBindings, as well as an optional conversation status constraint. A KeyBinding is a value that a key must have to satisfy a specific search. Similarly, a TemplateBinding tb of search s specifies a Template t such that a conversation c matches s if c contains an email e, and e is an instantiation of t.
For example, a search might specify that a conversation should be unread to be part of the search’s results. But we also want to allow users to specify constraints on their own Keys, e.g. coming? = “yes”. For that, we needed a flexible way to specify those constraints. So we came up with the concept of a KeyBinding; it “binds the free Key variable to a specific value”. So a KeyBinding associates a search with a Key that contains a specific value (todo: add comparison operators. e.g. age > 21).
Note that Searches are saved to the database. If they specify a template to be sent, we consider them to be “Rules” that can be automatically triggered. Otherwise they just clutter up the database and should eventually be purged by a cronjob. This persisting of searches could be used to remember recent searches.

\pagebreak
\subsection{ValueSettingActions}

\insertfigure{figures/cd_actions.pdf}{ValueSettingActions allow a template to set a certain Key's value to a predefined value. Together with Rules, this allows for custom, state-machine-like behavior specification.}{CD-Actions}{1}

\subsection{Notification}

Notifications are used to “notify” but not only. They also hold state (e.g. invalid user credentials) that can be used only internally by the system (e.g. to avoid syncing emails from users with invalid credentials). They are like “state” descriptors of other objects and in some cases these are visible to the users (e.g. we are syncing your spreadsheet), in other cases only the backend uses them. So maybe they should be called differently. (any ideas?)

They’re an abstract class that we might have taken a little too far. They basically contain a polymorphic Type field, and an ID. Then, madness ensues as we use this information to attach Notifications to any ActiveRecord::Base object in our database. There is a whole class hierarchy beneath Notification, containing classes like ErrorNotification, which uses aforementioned feature to attach Errors or warnings to basically anything. There are also very specific subclasses like TemplateSentToSearchResultsActivityNotification, which are used to notify users. Another example would be a SpreadsheetSyncingNotification, which is also used to inform users. You can define groups of Notification Subclasses that are displayed in different parts of the UI, for example on the Admin Dashboard or on top of the screen for the respective user, as a kind of persistent flash message.

\subsubsection{ActivityNotification}

These are used to display the activity stream, which is currently woefully underdeveloped.
They could also be used to record Assistant actions in the future. Maybe they could even be tied to resources to enable tracking of the last spreadsheet sync, etc.

\subsubsection{UnexpectedStateNotification}

We used these to make sure that all of those little instances where you’re writing a case statement without a default, expecting values to be of a certain type, etc *actually* never occur. And in reality, of course, they do. So if you’re almost certain a certain state should not be reached in a program, put an UnexpectedStateNotification there and be grateful when, two months later, your admin dashboard informs you that what you had deemed impossible happened 6,000 times last night.

\subsubsection{ExceptionNotification}

A simple way to “save” an exception for review from the Admin Dashboard. (Todo: Also save the stacktrace with these, so they might be even more useful.)

\subsubsection{ErrorNotification}

These might be named a little badly, since they can actually mean anything that is attached to a certain resource and might be resolved later on. For example, we could use these to implement an InvalidCredentialsErrorNotification. When, at a later point, the credentials work again, we’ll be able to call InvalidCredentialsErrorNotification.resolve and pass it the user object, deleting the InvalidCredentialsErrorNotification.
An example where these are used to notify not about an error, but simply about a state that’s attached to a resource is the SpreadsheetSyncingNotification.
A possibly better future name might be PersistentNotification or ResourceNotification.


\section{Backend Services Connection}



\subsection{Email Fetching}

As we spent a lot of time figuring out the intricacies of the Gmail IMAP implementation and the manifold cases that can occur when normal (or heavy) users go about their daily email business without considering the restrictions of poor Myriad, we want to spare you repeating the same. We hope to have brought the fetching and email creation logic to a relatively stable state, yet we are certain there remain a bunch of holes that could cause failures in edge cases.
If you do not need to touch the code, you might find the following explanation too detailed, so you shouldn't waste your time with it (bar this overview section). For anybody working with the fetching code, however, the following information should prove very useful - especially if you are unfamiliar with email headers, IMAP protocol details and the like.
In brief, our fetching process works as follows:
1.	Identifying emails on the Gmail server: First, we connect to the user's Gmail account and identify the UIDs (one of many types of email identifiers, see below for a more detailed explanation) of all emails we want to fetch. We use multiple different queries for that, which will later be explained in more detail. Before we move on to the next step, we filter out emails in our database whose UIDs we already know, i.e. have fetched before.
2.	Fetching and processing email data: For the remaining UIDs, we fetch the corresponding email from Gmail, create a Mail object (from the mail gem) for it and determine its type – IncomingFetchedEmail, OutgoingFetchedEmail, etc.
3.	Email creation in Myriad: As a last (but not trivial) step we try to use the information from the Mail object to create an Email object in Myriad.

\subsubsection{IMAP IDLEing}



\subsection{Google Docs Syncing}




\section{``Best Practices''}

During the development process we discovered a set of ``Best Practices'' that didn't seem to fit into any specific software development methodology.

\subsection{A fixed set of ruby core extensions}

A dynamic language like ruby makes it trivially easy to reopen core classes. [citation needed] While initially the convenience seems awesome, it's easy to lose track of already implemented extensions, you risk colliding method names\footnote{Ruby 2.0 finally fixed this by introducing \emph{refinements}, a way to extend classes namespaced to the current module.}, and reusability is higher if one just packages those extensions as a new class.

However we did decide to keep a couple of our extensions, which we felt were essential. Here's a list of them, together with explanations why they seem like good ideas:

\subsubsection{String}

\begin{description}

\item[remove\_all\_whitespace] A common task when interfacing with APIs, especially when interfacing with IMAP where one can't use a proper parser. This came up multiple times during development, and a commonly suggested solution is to use regular expressions, like so: |gsub /\s+/, ''|. While working perfectly fine, we wanted a more expressive name. This was left as an extension because similar whitespace altering functions like |.strip| or  |.squish| are also declared directly on |String|.
\\
\begin{lstlisting}
  "  This is a string  !   ".remove_all_whitespace
   => "Thisisastring!"
\end{lstlisting}

\item[similar\_to?] A custom equivalence class on |String|s, which are similar if one only considers numbers and downcased letters. This is used to match placeholders with spreadsheet column headers, for example.
In our experience users often used ``First Name'' instead of ``first\_name'' and we wanted to offer an equivalence class that was sufficiently big, while avoiding being totally fuzzy.
\\
\begin{lstlisting}
  "first_name".similar_to? "First Name"
   => true
\end{lstlisting}

\item[ellipsisize] Takes a string and information on how how much of it to keep. It adds an ellipsis where the string was cut off. We used it in many places throughout the interface, for example for only displaying the first line of a collapsed email.
\\
\begin{lstlisting}
  "Supercalifragilisticexpialidocious".ellipsisize
  => "Sup...ous"
\end{lstlisting}


\item[to\_bool] Once again an indication of working with badly specified protocols. This was needed after some Javascript libraries apparently disagree about how to encode |true| in a URL parameter.
\\
\begin{lstlisting}
  ['true', 't', 'yes', 'y', '1'].map(&:to_bool).all?
  => true
  ['false', 'f', 'no', 'n', '0'].map(&:to_bool).none?
  => true
\end{lstlisting}

\end{description}

\subsubsection{Hash}

\begin{description}

\item[deep\_find] This does a deep traversal of a Hash, looking for any key that matches the argument of this method. When working with APIs that return structured data the format is usually fixed, but we experienced slight inconsistencies for Google's different versions of its OAuth APIs. Of course this method will run into trouble if a key occurs multiple times, but when used in the right places, it makes parsing structured responses incredibly solid.
\\
\begin{lstlisting}
  nested_hash
  => {
      "a key"=>"a value",
      "a nested hash" =>
      {
        "another key"=>"another value",
        "the key"=>"the value"
      }
     }

  simple_hash
  => {
      "another key"=>"another value",
      "the key"=>"the value"}
     }

  simple_hash.deep_find "the key"
  => "the value"

  nested_hash.deep_find "the key"
  => "the value"
\end{lstlisting}

\end{description}

\subsubsection{Array}

\begin{description}

\item[uniq?] Checks whether all elements inside the receiving array are unique. This was not used to abuse |Array|s as |Set|s, but rather to check user input.

\item[contains\_duplicates?] Semantic alias of |not uniq?|, this was the method that was actually used in code.
\\
\begin{lstlisting}
  ['word', 'thing', 'word'].contains_duplicates?
  => true
\end{lstlisting}

\end{description}

\subsection{Lean Workers with AbstractWorker}

We’ve built an AbstractWorker Superclass for our Resque Workers. Why?
Basically I think Resque is awesome, but very, very basic.
When faced with the task to build a DRY function to start worker threads for all our workers, I found no simple way. So now, AbstractWorker takes care of generating queue names form the Class names of it’s subclasses, and I can use the result of the descendants method (returns all subclasses) to iterate over and start a worker thread with the correct queue. It also allowed us to extract the ResqueDirector plugin, which starts those workers in our Development environment.

\subsection{Monitoring Services}

Monit is an awesome tool that you configure via a DSL that ensures all parts of your appliction keep running. The most common way for monit to monitor an application is that this application writes its Unix process ID into a specific file. This way monit can check if this process is still alive. Big applications like nginx or mysql already do this for us. For things like workers or the above mentioned rake idle task we need a custom solution. Imho it would be best to use a deamonizer wrapper appor script, that does the starting and PID-into-a-file-writing generically. I wasted a few hours on several approaches and couldn’t get this to work, unfortunately.
So now our rake idle task writes it’s own PID file and is monit’d. Semi-awesome.

