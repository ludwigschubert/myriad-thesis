\chapter{Technical Background}
\label{chapter:Technical}

This chapter provides relevant technical background information. It motivates the decision to build a web app. Standard-compliant email systems are explained and relevant standards are introduced. Lastly, it gives an introduction to workflow systems and provides historic examples.

\section{Web Applications}

This section comprises an introduction to web applications and their development. It lays the foundation for the implementation details of the Myriad system in chapter \autoref{chapter:Implementation}.

Web applications, or, more precisely, \emph{web-based applications}, don't have a strict formal definition, but here the term is used in its common meaning\cite{webapptrends}: an application, which is accessed through a web browser. Unlike a traditional computer program that is usually written in a single programming language, compiled and then executed on a computer, a web application consists of many interoperating systems and programs, commonly not even run on the same machine. \footnote{While the distributed, non-homogeneous nature of web applications makes their development process more complex, it also afforded me the opportunity to learn about the full spectrum of the current unix eco-system.}

Traditionally, a website is comprised of static \gls{html} files and \gls{css} markup to display its content. To support the dynamic nature of user-specific \em{applications} rather than \em{documents}, a typical approach is to generate the \gls{html} files dynamically at request time. Together with client side executed javascript, this supports more interactivity. This is the current standard for many web development frameworks such as Ruby on Rails, Django or PHP.

Future Web Applications will most likely go further in their separation of concerns, shifting the application logic to the client side. With frameworks such as Sproutcore, which are served statically and execute all business logic on the client side in javascript while relying on the server mainly as a data source, one can already see the beginnings of this clearer, more mature development paradigm. As of the time of writing however\footnote{ \today }, the model of dynamically rendered \gls{html} files is still prominent. With larger communities and good documentation it is the de-facto standard of web application development.

\subsection{Software Stacks}

The client-side stack includes the webbrowser and javascript engine to interpret the \gls{html} and Javascript files from the webserver.

The server-side stack is tradtionally an assortment of tools, starting with an HTTP server such as |Apache| or |NginX|, which handle static file serving. The HTTP server forwards requests for dynamic content to a web server, such as |fast_cgi| or |Unicorn|. These may optionally have a middleware handler for web middlewares such as |Rack|, or forward directly to the web framework, which handles the business logic, database connections, etc.

Apart from this primary web stack many web applications rely on additional services running on the backend server. A simple example would be an additional Key-Value store for caching purposes, such as |Redis| or |MongoDB|. But infrastructure software, such as the common unix scheduler |cron|, backup tasks, SMTP servers, or background workers, are also part of the backend stack. All of these parts contribute to the end result and have to be managed and integrated in a process called deployment. The solution I chose for automating deployment is explained in \autoref{subsection:Deployment}.

\subsection{Ruby on Rails}



\insertfigure{figures/rails_architecture.png}{Ruby on Rails Architecture Diagram}{RailsArchitecture}{.75}{Picasa User ``Niwatori''}


\section{Email}


\subsection{RFC 2822}

Email is standardized as the ``Internet Message Format'' in RFC 2822\cite{email}.

\subsection{IMAP \& SMTP}

Hello \gls{imap}.


\section{Workflow Systems}


\subsection{History of Workflow Systems}


\subsection{Famous Examples}